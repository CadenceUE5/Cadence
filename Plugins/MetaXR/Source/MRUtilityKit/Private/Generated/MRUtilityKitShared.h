// Copyright (c) Meta Platforms, Inc. and affiliates.

// @generated by `buck2 run //arvr/projects/mixedreality/libraries/mrutilitykit:build_and_deploy unreal`

#pragma once

#include <float.h>
#include <stddef.h>
#include <stdint.h>
#include "CoreTypes.h"
#include "Math/UnrealMath.h"
#include "Math/MathFwd.h"

struct MRUKShared
{
    static MRUKShared* GetInstance() { return Instance; }

    static void LoadMRUKSharedLibrary();
    static void FreeMRUKSharedLibrary();

    struct MrukSceneAnchor;

    struct MrukRoomAnchor;

    struct MrukTrackable;

    struct MrukUuid;

    struct MrukPosef;

    enum MrukSceneModel
    {
        MRUK_SCENE_MODEL_V2_FALLBACK_V1 = 0,
        MRUK_SCENE_MODEL_V1 = 1,
        MRUK_SCENE_MODEL_V2 = 2,
    };

    enum MrukLogLevel
    {
        MRUK_LOG_LEVEL_DEBUG = 0,
        MRUK_LOG_LEVEL_INFO = 1,
        MRUK_LOG_LEVEL_WARN = 2,
        MRUK_LOG_LEVEL_ERROR = 3,
    };

    enum MrukResult
    {
        MRUK_SUCCESS = 0,
        MRUK_ERROR_INVALID_ARGS = 1,
        MRUK_ERROR_UNKNOWN = 2,
        MRUK_ERROR_INTERNAL = 3,
        MRUK_ERROR_DISCOVERY_ONGOING = 4,
        MRUK_ERROR_INVALID_JSON = 5,
        MRUK_ERROR_NO_ROOMS_FOUND = 6,
        MRUK_ERROR_INSUFFICIENT_RESOURCES = 7,
        MRUK_ERROR_STORAGE_AT_CAPACITY = 8,
        MRUK_ERROR_INSUFFICIENT_VIEW = 9,
        MRUK_ERROR_PERMISSION_INSUFFICIENT = 10,
        MRUK_ERROR_RATE_LIMITED = 11,
        MRUK_ERROR_TOO_DARK = 12,
        MRUK_ERROR_TOO_BRIGHT = 13,
    };

    enum MrukSurfaceType
    {
        MRUK_SURFACE_TYPE_NONE = 0,
        MRUK_SURFACE_TYPE_PLANE = 1,
        MRUK_SURFACE_TYPE_VOLUME = 2,
        MRUK_SURFACE_TYPE_MESH = 4,
        MRUK_SURFACE_TYPE_ALL = 7,
    };

    enum MrukLabel
    {
        MRUK_LABEL_FLOOR = 1,
        MRUK_LABEL_CEILING = 2,
        MRUK_LABEL_WALL_FACE = 4,
        MRUK_LABEL_TABLE = 8,
        MRUK_LABEL_COUCH = 16,
        MRUK_LABEL_DOOR_FRAME = 32,
        MRUK_LABEL_WINDOW_FRAME = 64,
        MRUK_LABEL_OTHER = 128,
        MRUK_LABEL_STORAGE = 256,
        MRUK_LABEL_BED = 512,
        MRUK_LABEL_SCREEN = 1024,
        MRUK_LABEL_LAMP = 2048,
        MRUK_LABEL_PLANT = 4096,
        MRUK_LABEL_WALL_ART = 8192,
        MRUK_LABEL_SCENE_MESH = 16384,
        MRUK_LABEL_INVISIBLE_WALL_FACE = 32768,
        MRUK_LABEL_UNKNOWN = 131072,
        MRUK_LABEL_INNER_WALL_FACE = 262144,
        MRUK_LABEL_TABLETOP = 524288,
        MRUK_LABEL_SITTING_AREA = 1048576,
        MRUK_LABEL_SLEEPING_AREA = 2097152,
        MRUK_LABEL_STORAGE_TOP = 4194304,
    };

    enum MrukTrackableType
    {
        MRUK_TRACKABLE_TYPE_NONE = 0,
        MRUK_TRACKABLE_TYPE_KEYBOARD = 1,
        MRUK_TRACKABLE_TYPE_QRCODE = 2,
    };

    enum MrukMarkerPayloadType
    {
        MRUK_MARKER_PAYLOAD_TYPE_NONE = 0,
        MRUK_MARKER_PAYLOAD_TYPE_INVALID_QRCODE = 1,
        MRUK_MARKER_PAYLOAD_TYPE_STRING_QRCODE = 2,
        MRUK_MARKER_PAYLOAD_TYPE_BINARY_QRCODE = 3,
    };

    enum MrukEnvironmentRaycastStatus
    {
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT = 1,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_NO_HIT = 2,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT_POINT_OCCLUDED = 3,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_HIT_POINT_OUTSIDE_FOV = 4,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_RAY_OCCLUDED = 5,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_INVALID_ORIENTATION = 6,
        MRUK_ENVIRONMENT_RAYCAST_STATUS_MAX = 2147483647,
    };

    typedef void (*LogPrinter)(MrukLogLevel logLevel, const char* message, uint32_t length);

    typedef void (*MrukOnPreRoomAnchorAdded)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnRoomAnchorAdded)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnRoomAnchorUpdated)(const MrukRoomAnchor* roomAnchor, const MrukUuid* oldRoomAnchorUuid, bool significantChange, void* userContext);

    typedef void (*MrukOnRoomAnchorRemoved)(const MrukRoomAnchor* roomAnchor, void* userContext);

    typedef void (*MrukOnSceneAnchorAdded)(const MrukSceneAnchor* sceneAnchor, void* userContext);

    typedef void (*MrukOnSceneAnchorUpdated)(const MrukSceneAnchor* sceneAnchor, bool significantChange, void* userContext);

    typedef void (*MrukOnSceneAnchorRemoved)(const MrukSceneAnchor* sceneAnchor, void* userContext);

    typedef void (*MrukOnDiscoveryFinished)(MrukResult result, void* userContext);

    typedef void (*MrukOnEnvironmentRaycasterCreated)(MrukResult result, void* userContext);

    typedef void (*MrukOnTrackersConfigured)(MrukResult result, void* userContext);

    typedef void (*MrukOnTrackableAdded)(const MrukTrackable* trackable, void* userContext);

    typedef void (*MrukOnTrackableUpdated)(const MrukTrackable* trackable, void* userContext);

    typedef void (*MrukOnTrackableRemoved)(const MrukTrackable* trackable, void* userContext);

    typedef struct MrukPosef (*TrackingSpacePoseGetter)();

    typedef void (*TrackingSpacePoseSetter)(MrukPosef pose);

    struct MrukLabelFilter
    {
        uint32_t surfaceType;
        uint32_t includedLabels;
        bool includedLabelsSet;
    };

    struct MrukQuatf
    {
        float x;
        float y;
        float z;
        float w;
    };

    struct MrukPosef
    {
        FVector3f position;
        MrukQuatf rotation;
    };

    struct MrukPolygon2f
    {
        const FVector2f* points;
        uint32_t numPoints;
    };

    struct MrukMesh2f
    {
        FVector2f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };

    struct MrukMesh3f
    {
        FVector3f* vertices;
        uint32_t numVertices;
        uint32_t* indices;
        uint32_t numIndices;
    };

    struct MrukUuid
    {
        uint8_t data[16];
    };

    struct MrukVolume
    {
        FVector3f min;
        FVector3f max;
    };

    struct MrukPlane
    {
        float x;
        float y;
        float width;
        float height;
    };

    struct MrukSceneAnchor
    {
        uint64_t space;
        MrukUuid uuid;
        MrukUuid roomUuid;
        MrukUuid parentUuid;
        MrukPosef pose;
        MrukVolume volume;
        MrukPlane plane;
        MrukLabel semanticLabel;
        const FVector2f* planeBoundary;
        const uint32_t* globalMeshIndices;
        const FVector3f* globalMeshPositions;
        uint32_t planeBoundaryCount;
        uint32_t globalMeshIndicesCount;
        uint32_t globalMeshPositionsCount;
        bool hasVolume;
        bool hasPlane;
    };

    struct MrukRoomFace
    {
        MrukUuid uuid;
        MrukUuid parentUuid;
        MrukLabel semanticLabel;
        const uint32_t* indices;
        uint32_t indicesCount;
    };

    struct MrukRoomMesh
    {
        const FVector3f* vertices;
        MrukRoomFace* faces;
        uint32_t verticesCount;
        uint32_t facesCount;
    };

    struct MrukRoomAnchor
    {
        MrukSceneModel sceneModel;
        uint64_t space;
        MrukUuid uuid;
        MrukPosef pose;
        MrukRoomMesh roomMesh;
    };

    struct MrukTrackable
    {
        MrukTrackableType trackableType;
        MrukMarkerPayloadType markerPayloadType;
        uint64_t space;
        MrukUuid uuid;
        MrukPosef pose;
        MrukVolume volume;
        MrukPlane plane;
        const FVector2f* planeBoundary;
        const uint8_t* payload;
        uint32_t planeBoundaryCount;
        uint32_t payloadCount;
        bool hasVolume;
        bool hasPlane;
        bool isTracked;
    };

    struct MrukEventListener
    {
        MrukOnPreRoomAnchorAdded onPreRoomAnchorAdded;
        MrukOnRoomAnchorAdded onRoomAnchorAdded;
        MrukOnRoomAnchorUpdated onRoomAnchorUpdated;
        MrukOnRoomAnchorRemoved onRoomAnchorRemoved;
        MrukOnSceneAnchorAdded onSceneAnchorAdded;
        MrukOnSceneAnchorUpdated onSceneAnchorUpdated;
        MrukOnSceneAnchorRemoved onSceneAnchorRemoved;
        MrukOnDiscoveryFinished onDiscoveryFinished;
        MrukOnEnvironmentRaycasterCreated onEnvironmentRaycasterCreated;
        MrukOnTrackersConfigured onTrackersConfigured;
        MrukOnTrackableAdded onTrackableAdded;
        MrukOnTrackableUpdated onTrackableUpdated;
        MrukOnTrackableRemoved onTrackableRemoved;
        void* userContext;
    };

    struct MrukHit
    {
        MrukUuid roomAnchorUuid;
        MrukUuid sceneAnchorUuid;
        float hitDistance;
        FVector3f hitPosition;
        FVector3f hitNormal;
    };

    struct MrukSharedRoomsData
    {
        MrukUuid groupUuid;
        MrukUuid* roomUuids;
        uint32_t numRoomUuids;
        MrukUuid alignmentRoomUuid;
        MrukPosef roomWorldPoseOnHost;
    };

    struct _MrukUuidAlignmentTest
    {
        uint8_t padding;
        MrukUuid uuid;
    };

    struct MrukEnvironmentRaycastHitPointGetInfo
    {
        FVector3f startPoint;
        FVector3f direction;
        uint32_t filterCount;
        float maxDistance;
    };

    struct MrukEnvironmentRaycastHitPoint
    {
        MrukEnvironmentRaycastStatus status;
        FVector3f point;
        MrukQuatf orientation;
        FVector3f normal;
    };

    struct MrukVector2i
    {
        int x;
        int y;
    };

    struct MrukCameraIntrinsics
    {
        FVector2f focalLength;
        FVector2f principalPoint;
        FVector3f lensTranslation;
        MrukQuatf lensRotation;
        MrukVector2i sensorResolution;
    };


    /**
     * This allows the engine to intercept the logs from the shared library and print them using the
     * engine's logging system. Note that the log lines are NOT NULL terminated, and so you must take
     * into account the length and be careful not to read past it.
     */
    void (*SetLogPrinter)(LogPrinter printer);

    /**
     * This should only be called once on application startup to create the global context. This is a
     * pre-requisite to call all of the other APIs. When the context is not needed anymore it should be
     * destroyed with ContextDestroy() to free resources (i.e. when the application is shutdown).
     */
    MrukResult (*CreateGlobalContext)();

    /**
     * Destroy the global context
     * This should only be called once on application shutdown.
     */
    void (*DestroyGlobalContext)();

    /**
     * Initialize OpenXR with an external OpenXR instance and session.
     * This should only be called once on application startup.
     * Make sure to hook up the OnOpenXrEvent() function as well.
     * If the context is not needed anymore it should be destroyed with ContextDestroy() to free
     * resources.
     */
    MrukResult (*InitOpenXr)(uint64_t xrInstance, uint64_t xrSession, void* xrInstanceProcAddrFunc, uint64_t baseSpace, const char** availableOpenXrExtensions, uint32_t availableOpenXrExtensionsCount);

    /**
     * This should be called when the OpenXR instance is destroyed and it is no longer valid to attempt
     * to make any OpenXR calls. This can happen with Link when exiting play mode.
     */
    void (*ShutdownOpenXr)();

    /**
     * Initialize the Unity interfaces. This should be called once after the global context has been
     * created. See https://docs.unity3d.com/6000.1/Documentation/Manual/native-plugin-interface.html
     * for more details. Note that the usual UnityPluginLoad and UnityPluginUnload functions will not be
     * called automatically by unity because the MRUK Shared Library is loaded dynamically at runtime to
     * allow hot reloading. So we must explicitly call this ourselves to get access to the interface.
     *
     * @param[in] unityInterfaces A pointer to IUnityInterfaces
     */
    void (*InitUnityInterfaces)(void* unityInterfaces);

    /**
     * If the base space changes after initialization, this function should be called to update the
     * base space.
     */
    void (*SetBaseSpace)(uint64_t baseSpace);

    /**
     * Start anchor discovery in the global context
     */
    MrukResult (*StartDiscovery)(bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Start anchor query from shared group uuid in the global context
     */
    MrukResult (*StartQueryByLocalGroup)(MrukSharedRoomsData sharedRoomsData, bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Load the scene from a json string
     */
    MrukResult (*LoadSceneFromJson)(const char* jsonString, bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

    /**
     * Save the scene to a json string.
     * @return The serialized JSON string. This string must be freed with FreeJson after use!
     */
    const char* (*SaveSceneToJson)(bool includeGlobalMesh, MrukUuid* roomUuids, uint32_t numRoomUuids);

    /**
     * Free the json string returned by SaveSceneToJson.
     * @param[in] jsonString The JSON string to free.
     */
    void (*FreeJson)(const char* jsonString);

    /**
     * Given a prefabricated scene description, load it in the global context.
     */
    MrukResult (*LoadSceneFromPrefab)(MrukRoomAnchor* roomAnchors, uint32_t numRoomAnchors, MrukSceneAnchor* sceneAnchors, uint32_t numSceneAnchors);

    /**
     * Clear and remove all rooms in the global context.
     */
    void (*ClearRooms)();

    /**
     * Clear and remove the room that matches the given uuid.
     */
    void (*ClearRoom)(MrukUuid roomUuid);

    /**
     * Allows to forward OpenXR events from the engine into the shared library
     */
    void (*OnOpenXrEvent)(void* baseEventHeader);

    /**
     * Needs to be called every tick by the engine.
     */
    void (*TickGlobalContext)(uint64_t nextPredictedDisplayTime);
    void (*RegisterEventListener)(MrukEventListener listener);

    /**
     * Cast a ray against all anchors in the room and return the first hit.
     * A maxDistance of <= 0 will return the first hit regardless of distance.
     */
    bool (*RaycastRoom)(MrukUuid roomUuid, FVector3f origin, FVector3f direction, float maxDistance, MrukLabelFilter labelFilter, MrukHit* outHit);

    /**
     * Cast a ray against all anchors in the room and return all hits along the ray.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*RaycastRoomAll)(MrukUuid roomUuid, FVector3f origin, FVector3f direction, float maxDistance, MrukLabelFilter labelFilter, MrukHit* outHits, uint32_t* outHitsCount);

    /**
     * Cast a ray against the anchor in the room and return the first hit.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*RaycastAnchor)(MrukUuid sceneAnchorUuid, FVector3f origin, FVector3f direction, float maxDistance, uint32_t surfaceTypes, MrukHit* outHit);

    /**
     * Cast a ray against the anchor in the room and return all hits along the ray.
     * A maxDistance of <= 0 will return the hits along the ray regardless of distance.
     */
    bool (*RaycastAnchorAll)(MrukUuid sceneAnchorUuid, FVector3f origin, FVector3f direction, float maxDistance, uint32_t surfaceTypes, MrukHit* outHits, uint32_t* outHitsCount);

    /**
     * Check if the given position is in the room or not.
     *
     * @param[in] roomUuid The unique identifier for the room.
     * @param[in] position The 3D position to check.
     * @param[in] testVerticalBounds A boolean indicating whether to test vertical bounds. If false then
     * the point will be considered inside as long as it is within the perimeter of the room regardless
     * of whether the point is below the floor or above the ceiling.
     * @return True if the position is within the room, false otherwise.
     */
    bool (*IsPositionInRoom)(MrukUuid roomUuid, FVector3f position, bool testVerticalBounds);

    /**
     * Gets the current room the headset is in. If the headset is not in any given room
     * then it will return the room the headset was last in when this function was called.
     * If the headset hasn't been in a valid room yet then return the first room in the list.
     * If no rooms have been loaded yet then return false.
     *
     * @param[out] outRoomUuid Pointer to a MrukUuid that will be filled with the current room UUID.
     * @return True if a room was found, false otherwise.
     */
    bool (*GetCurrentRoom)(MrukUuid* outRoomUuid);

    /**
     * Checks whether scene anchor discovery is currently in progress.
     *
     * @return True if discovery is ongoing (either actively loading scene data or
     * performing background processing like BVH building), false if discovery
     * hasn't started yet or has completely finished.
     */
    bool (*IsDiscoveryRunning)();

    /**
     * Get the world lock offset for the current room. This is the difference between the room's initial
     * pose when it was created and the current pose.
     */
    bool (*GetWorldLockOffset)(MrukPosef* offset);

    /**
     * Add two vectors together. This is implemented as a test to ensure the native shared
     * library is working correctly.
     *
     * @param[in] a The first vector.
     * @param[in] b The second vector.
     * @return The sum of the two vectors.
     */
    FVector3f (*AddVectors)(FVector3f a, FVector3f b);

    /**
     * Triangulate a polygon with holes, any winding order works. The first polyline defines the main
     * polygon. Following polylines define holes. This function will allocate memory for the vertices
     * and indices. You *MUST* call FreeMesh() when you are done with it or you will leak memory.
     *
     * @param[in] polygons The polygon to triangulate.
     * @param[in] numPolygons The number of polygons in the array.
     * @return mesh The triangulated mesh.
     */
    MrukMesh2f (*TriangulatePolygon)(const MrukPolygon2f* polygons, uint32_t numPolygons);

    /**
     * Free the memory allocated by TriangulatePolygon.
     *
     * @param[in] mesh The mesh to free.
     */
    void (*FreeMesh)(MrukMesh2f* mesh);

    /**
     * Compute the mesh segmentation for a given set of vertices, indices and points per unit.
     * The function will automatically generate segmentation points in a uniform voxel grid
     * within the mesh bounds. You *MUST* call FreeMeshSegmentation() on the meshSegments array when you
     * are done with it or you will leak memory.
     *
     * @param[in] vertices The mesh vertices.
     * @param[in] numVertices The number of vertices in the mesh.
     * @param[in] indices The mesh indices.
     * @param[in] numIndices The number of indices in the mesh.
     * @param[in] pointsPerUnitX The number of points per unit along the X axis.
     * @param[in] pointsPerUnitY The number of points per unit along the Y axis.
     * @param[in] pointsPerUnitZ The number of points per unit along the Z axis.
     * @param[in] reservedMin The minimum bounding box for the reserved segment.
     * @param[in] reservedMax The maximum bounding box for the reserved segment.
     * @param[out] meshSegments The resulting segments.
     * @param[out] numSegments The number of segments in the resulting array.
     * @param[out] reservedSegment The segment that is inside the reserved bounding box.
     */
    MrukResult (*ComputeMeshSegmentation)(const FVector3f* vertices, uint32_t numVertices, const uint32_t* indices, uint32_t numIndices, float pointsPerUnitX, float pointsPerUnitY, float pointsPerUnitZ, FVector3f reservedMin, FVector3f reservedMax, MrukMesh3f** meshSegments, uint32_t* numSegments, MrukMesh3f* reservedSegment);

    /**
     * Free the memory allocated by ComputeMeshSegmentation.
     *
     * @param[in] meshSegments The array of segments to free.
     * @param[in] numSegments The number of segments in the array.
     * @param[in] reservedSegment The reserved segment to free.
     */
    void (*FreeMeshSegmentation)(const MrukMesh3f* meshSegments, uint32_t numSegments, MrukMesh3f* reservedSegment);

    /**
     * The is a test function purely to test the marshalling of Uuid from C# to C++. It ensures that the
     * packing between clang C++ and the C# definitions of MrukUuid are compatible.
     *
     * @param[in] packedUuid A uuid packed into a structure.
     * @return A copy of the uuid that was passed in the structure.
     */
    MrukUuid (*_TestUuidMarshalling)(_MrukUuidAlignmentTest packedUuid);

    /**
     * Converts the given label to the matching MrukLabel.
     *
     * @param[in] label The label as string.
     * @return The converted MrukLabel.
     */
    MrukLabel (*StringToMrukLabel)(const char* label);

    /**
     * Creates the enviornment raycaster and fires the onEnvironmentRaycasterCreated event when the
     * creation is complete.
     */
    void (*CreateEnvironmentRaycaster)();

    /**
     * Destroys the enviornment raycaster.
     */
    void (*DestroyEnvironmentRaycaster)();

    /**
     * Performs an environment raycast.
     * Ensure that the environment raycaster is created before calling this function.
     * @param[in] info The raycast info.
     * @param[out] hitPoint The hit point.
     */
    void (*PerformEnvironmentRaycast)(const MrukEnvironmentRaycastHitPointGetInfo* info, MrukEnvironmentRaycastHitPoint* hitPoint);
    void (*SetTrackingSpacePoseGetter)(TrackingSpacePoseGetter getter);
    void (*SetTrackingSpacePoseSetter)(TrackingSpacePoseSetter setter);

    /**
     * Configures the tracker services. This should only be called after the global context
     * has been created. The trackers that should be enabled can be passed in trackableMask.
     * 0 means all trackers will be disabled.
     * The event onTrackersConfigured will be emitted after the tracker service is ready or failed to
     * start.
     *
     * @param[in] trackableMask A bitmask of MrukTrackableType
     */
    void (*ConfigureTrackers)(uint32_t trackableMask);

    /**
     * Set the interval in which trackers will be queried from the system and updated.
     * @param[in] millseconds Time in millseconds between updates
     */
    void (*SetTrackersUpdateInterval)(uint64_t millseconds);

    /**
     * Gets the supported resolutions for the specified camera.
     * This function allocates a buffer in C++ and returns a pointer to it.
     * The caller is responsible for freeing the buffer by calling CameraFreeSupportedResolutions.
     *
     * @param[in] eyeIndex The index of the camera.
     * @param[out] len Will be set to the number of available resolutions.
     * @return A pointer to an array of MrukVector2i structures, where x is the width and y is the
     * height. The caller must free this buffer by calling CameraFreeSupportedResolutions. Returns NULL
     * if no resolutions are available or an error occurred.
     */
    MrukVector2i* (*CameraGetSupportedResolutions)(int eyeIndex, int* len);

    /**
     * Frees the buffer allocated by CameraGetSupportedResolutions.
     *
     * @param[in] buffer The buffer to free.
     */
    void (*CameraFreeSupportedResolutions)(MrukVector2i* buffer);

    /**
     * Starts the camera capture for the specified camera.
     * @param[in] eyeIndex The index of the camera to start.
     * @param[out] width The width of the camera frames that will be captured.
     * @param[out] height The height of the camera frames that will be captured.
     * @param[out] intrinsics The intrinsic parameters of the camera.
     * @return True if the camera was successfully started, false otherwise.
     */
    bool (*CameraPlay)(int eyeIndex, int* width, int* height, MrukCameraIntrinsics* intrinsics);

    /**
     * Acquires the latest image from the camera.
     * The caller must call CameraReleaseLatestImage() afterwards, even if the returned buffer is null.
     * @param[in] eyeIndex The index of the camera.
     * @param[out] timestampMicrosecondsRealtime Timestamp of the image in microseconds since
     * the Unix epoch.
     * @param[out] timestampNsMonotonic Timestamp of the image in monotonic nanoseconds. Used for
     * getting the precise headset pose at the image's timestamp.
     * @return A pointer to a buffer containing the RGBA (32 bits, 8 bits per channel) image data. If
     * null, this means no new image is available.
     */
    uint8_t* (*CameraAcquireLatestImage)(int eyeIndex, int64_t* timestampMicrosecondsRealtime, int64_t* timestampNsMonotonic);

    /**
     * Releases the image buffer acquired by CameraAcquireLatestImage().
     * Must be called even if CameraAcquireLatestImage() returns null.
     */
    void (*CameraReleaseLatestImage)(int eyeIndex);

    /**
     * Notifies the camera system that the application has gained focus.
     * This should be called when the application regains focus after being in the background.
     */
    void (*CameraOnApplicationFocused)();

    /**
     * Stops the camera capture for the specified camera.
     * @param[in] eyeIndex The index of the camera to stop.
     */
    void (*CameraStop)(int eyeIndex);
    double (*ConvertToXrTimeInSeconds)(int64_t timeNsMonotonic);

private:

    void LoadNativeFunctions()
    {
        SetLogPrinter = reinterpret_cast<decltype(SetLogPrinter)>(LoadFunction(TEXT("SetLogPrinter")));
        CreateGlobalContext = reinterpret_cast<decltype(CreateGlobalContext)>(LoadFunction(TEXT("CreateGlobalContext")));
        DestroyGlobalContext = reinterpret_cast<decltype(DestroyGlobalContext)>(LoadFunction(TEXT("DestroyGlobalContext")));
        InitOpenXr = reinterpret_cast<decltype(InitOpenXr)>(LoadFunction(TEXT("InitOpenXr")));
        ShutdownOpenXr = reinterpret_cast<decltype(ShutdownOpenXr)>(LoadFunction(TEXT("ShutdownOpenXr")));
        InitUnityInterfaces = reinterpret_cast<decltype(InitUnityInterfaces)>(LoadFunction(TEXT("InitUnityInterfaces")));
        SetBaseSpace = reinterpret_cast<decltype(SetBaseSpace)>(LoadFunction(TEXT("SetBaseSpace")));
        StartDiscovery = reinterpret_cast<decltype(StartDiscovery)>(LoadFunction(TEXT("StartDiscovery")));
        StartQueryByLocalGroup = reinterpret_cast<decltype(StartQueryByLocalGroup)>(LoadFunction(TEXT("StartQueryByLocalGroup")));
        LoadSceneFromJson = reinterpret_cast<decltype(LoadSceneFromJson)>(LoadFunction(TEXT("LoadSceneFromJson")));
        SaveSceneToJson = reinterpret_cast<decltype(SaveSceneToJson)>(LoadFunction(TEXT("SaveSceneToJson")));
        FreeJson = reinterpret_cast<decltype(FreeJson)>(LoadFunction(TEXT("FreeJson")));
        LoadSceneFromPrefab = reinterpret_cast<decltype(LoadSceneFromPrefab)>(LoadFunction(TEXT("LoadSceneFromPrefab")));
        ClearRooms = reinterpret_cast<decltype(ClearRooms)>(LoadFunction(TEXT("ClearRooms")));
        ClearRoom = reinterpret_cast<decltype(ClearRoom)>(LoadFunction(TEXT("ClearRoom")));
        OnOpenXrEvent = reinterpret_cast<decltype(OnOpenXrEvent)>(LoadFunction(TEXT("OnOpenXrEvent")));
        TickGlobalContext = reinterpret_cast<decltype(TickGlobalContext)>(LoadFunction(TEXT("TickGlobalContext")));
        RegisterEventListener = reinterpret_cast<decltype(RegisterEventListener)>(LoadFunction(TEXT("RegisterEventListener")));
        RaycastRoom = reinterpret_cast<decltype(RaycastRoom)>(LoadFunction(TEXT("RaycastRoom")));
        RaycastRoomAll = reinterpret_cast<decltype(RaycastRoomAll)>(LoadFunction(TEXT("RaycastRoomAll")));
        RaycastAnchor = reinterpret_cast<decltype(RaycastAnchor)>(LoadFunction(TEXT("RaycastAnchor")));
        RaycastAnchorAll = reinterpret_cast<decltype(RaycastAnchorAll)>(LoadFunction(TEXT("RaycastAnchorAll")));
        IsPositionInRoom = reinterpret_cast<decltype(IsPositionInRoom)>(LoadFunction(TEXT("IsPositionInRoom")));
        GetCurrentRoom = reinterpret_cast<decltype(GetCurrentRoom)>(LoadFunction(TEXT("GetCurrentRoom")));
        IsDiscoveryRunning = reinterpret_cast<decltype(IsDiscoveryRunning)>(LoadFunction(TEXT("IsDiscoveryRunning")));
        GetWorldLockOffset = reinterpret_cast<decltype(GetWorldLockOffset)>(LoadFunction(TEXT("GetWorldLockOffset")));
        AddVectors = reinterpret_cast<decltype(AddVectors)>(LoadFunction(TEXT("AddVectors")));
        TriangulatePolygon = reinterpret_cast<decltype(TriangulatePolygon)>(LoadFunction(TEXT("TriangulatePolygon")));
        FreeMesh = reinterpret_cast<decltype(FreeMesh)>(LoadFunction(TEXT("FreeMesh")));
        ComputeMeshSegmentation = reinterpret_cast<decltype(ComputeMeshSegmentation)>(LoadFunction(TEXT("ComputeMeshSegmentation")));
        FreeMeshSegmentation = reinterpret_cast<decltype(FreeMeshSegmentation)>(LoadFunction(TEXT("FreeMeshSegmentation")));
        _TestUuidMarshalling = reinterpret_cast<decltype(_TestUuidMarshalling)>(LoadFunction(TEXT("_TestUuidMarshalling")));
        StringToMrukLabel = reinterpret_cast<decltype(StringToMrukLabel)>(LoadFunction(TEXT("StringToMrukLabel")));
        CreateEnvironmentRaycaster = reinterpret_cast<decltype(CreateEnvironmentRaycaster)>(LoadFunction(TEXT("CreateEnvironmentRaycaster")));
        DestroyEnvironmentRaycaster = reinterpret_cast<decltype(DestroyEnvironmentRaycaster)>(LoadFunction(TEXT("DestroyEnvironmentRaycaster")));
        PerformEnvironmentRaycast = reinterpret_cast<decltype(PerformEnvironmentRaycast)>(LoadFunction(TEXT("PerformEnvironmentRaycast")));
        SetTrackingSpacePoseGetter = reinterpret_cast<decltype(SetTrackingSpacePoseGetter)>(LoadFunction(TEXT("SetTrackingSpacePoseGetter")));
        SetTrackingSpacePoseSetter = reinterpret_cast<decltype(SetTrackingSpacePoseSetter)>(LoadFunction(TEXT("SetTrackingSpacePoseSetter")));
        ConfigureTrackers = reinterpret_cast<decltype(ConfigureTrackers)>(LoadFunction(TEXT("ConfigureTrackers")));
        SetTrackersUpdateInterval = reinterpret_cast<decltype(SetTrackersUpdateInterval)>(LoadFunction(TEXT("SetTrackersUpdateInterval")));
        CameraGetSupportedResolutions = reinterpret_cast<decltype(CameraGetSupportedResolutions)>(LoadFunction(TEXT("CameraGetSupportedResolutions")));
        CameraFreeSupportedResolutions = reinterpret_cast<decltype(CameraFreeSupportedResolutions)>(LoadFunction(TEXT("CameraFreeSupportedResolutions")));
        CameraPlay = reinterpret_cast<decltype(CameraPlay)>(LoadFunction(TEXT("CameraPlay")));
        CameraAcquireLatestImage = reinterpret_cast<decltype(CameraAcquireLatestImage)>(LoadFunction(TEXT("CameraAcquireLatestImage")));
        CameraReleaseLatestImage = reinterpret_cast<decltype(CameraReleaseLatestImage)>(LoadFunction(TEXT("CameraReleaseLatestImage")));
        CameraOnApplicationFocused = reinterpret_cast<decltype(CameraOnApplicationFocused)>(LoadFunction(TEXT("CameraOnApplicationFocused")));
        CameraStop = reinterpret_cast<decltype(CameraStop)>(LoadFunction(TEXT("CameraStop")));
        ConvertToXrTimeInSeconds = reinterpret_cast<decltype(ConvertToXrTimeInSeconds)>(LoadFunction(TEXT("ConvertToXrTimeInSeconds")));
    }

    void UnloadNativeFunctions()
    {
        SetLogPrinter = nullptr;
        CreateGlobalContext = nullptr;
        DestroyGlobalContext = nullptr;
        InitOpenXr = nullptr;
        ShutdownOpenXr = nullptr;
        InitUnityInterfaces = nullptr;
        SetBaseSpace = nullptr;
        StartDiscovery = nullptr;
        StartQueryByLocalGroup = nullptr;
        LoadSceneFromJson = nullptr;
        SaveSceneToJson = nullptr;
        FreeJson = nullptr;
        LoadSceneFromPrefab = nullptr;
        ClearRooms = nullptr;
        ClearRoom = nullptr;
        OnOpenXrEvent = nullptr;
        TickGlobalContext = nullptr;
        RegisterEventListener = nullptr;
        RaycastRoom = nullptr;
        RaycastRoomAll = nullptr;
        RaycastAnchor = nullptr;
        RaycastAnchorAll = nullptr;
        IsPositionInRoom = nullptr;
        GetCurrentRoom = nullptr;
        IsDiscoveryRunning = nullptr;
        GetWorldLockOffset = nullptr;
        AddVectors = nullptr;
        TriangulatePolygon = nullptr;
        FreeMesh = nullptr;
        ComputeMeshSegmentation = nullptr;
        FreeMeshSegmentation = nullptr;
        _TestUuidMarshalling = nullptr;
        StringToMrukLabel = nullptr;
        CreateEnvironmentRaycaster = nullptr;
        DestroyEnvironmentRaycaster = nullptr;
        PerformEnvironmentRaycast = nullptr;
        SetTrackingSpacePoseGetter = nullptr;
        SetTrackingSpacePoseSetter = nullptr;
        ConfigureTrackers = nullptr;
        SetTrackersUpdateInterval = nullptr;
        CameraGetSupportedResolutions = nullptr;
        CameraFreeSupportedResolutions = nullptr;
        CameraPlay = nullptr;
        CameraAcquireLatestImage = nullptr;
        CameraReleaseLatestImage = nullptr;
        CameraOnApplicationFocused = nullptr;
        CameraStop = nullptr;
        ConvertToXrTimeInSeconds = nullptr;
    }

    void* LoadFunction(const TCHAR* ProcName);

    static MRUKShared* Instance;
    void* MRUKSharedHandle;

    MRUKShared(void* handle);
    ~MRUKShared();
};
